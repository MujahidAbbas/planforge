<?php

namespace App\Services\Exports;

use App\Enums\DocumentType;
use App\Enums\ExportStatus;
use App\Enums\ExportType;
use App\Models\Export;
use App\Models\Project;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use ZipArchive;

class ProjectKitExporter
{
    public function export(Project $project, ?int $userId = null): Export
    {
        $project->load(['documents.currentVersion', 'tasks', 'planRuns' => fn ($q) => $q->latest()->limit(1)]);

        $export = Export::create([
            'project_id' => $project->id,
            'user_id' => $userId,
            'type' => ExportType::ProjectKit,
            'status' => ExportStatus::Building,
            'disk' => 'local',
        ]);

        try {
            $zipPath = $this->buildZip($project, $export);

            $export->update([
                'status' => ExportStatus::Ready,
                'path' => $zipPath,
                'filename' => $this->generateFilename($project),
                'size_bytes' => Storage::disk('local')->size($zipPath),
                'expires_at' => now()->addDays(7),
            ]);
        } catch (\Throwable $e) {
            $export->update([
                'status' => ExportStatus::Failed,
                'error_message' => $e->getMessage(),
            ]);

            throw $e;
        }

        return $export;
    }

    private function buildZip(Project $project, Export $export): string
    {
        $tempDir = sys_get_temp_dir().'/'.Str::uuid();
        mkdir($tempDir, 0755, true);
        mkdir($tempDir.'/docs', 0755, true);
        mkdir($tempDir.'/kanban', 0755, true);

        // Generate files
        file_put_contents($tempDir.'/README.md', $this->generateReadme($project));
        file_put_contents($tempDir.'/docs/PRD.md', $this->getPrdContent($project));
        file_put_contents($tempDir.'/docs/TECH.md', $this->getTechContent($project));
        file_put_contents($tempDir.'/kanban/tasks.json', $this->generateTasksJson($project));
        file_put_contents($tempDir.'/kanban/tasks.csv', $this->generateTasksCsv($project));
        file_put_contents($tempDir.'/meta.json', $this->generateMeta($project));

        // Create ZIP
        $zipPath = "exports/{$project->id}/{$export->id}.zip";
        $tempZipPath = $tempDir.'.zip';

        $zip = new ZipArchive;
        if ($zip->open($tempZipPath, ZipArchive::CREATE | ZipArchive::OVERWRITE) !== true) {
            throw new \RuntimeException('Failed to create ZIP archive');
        }

        $this->addDirectoryToZip($zip, $tempDir, '');
        $zip->close();

        // Move to storage
        Storage::disk('local')->makeDirectory(dirname($zipPath));
        Storage::disk('local')->put($zipPath, file_get_contents($tempZipPath));

        // Cleanup temp files
        $this->deleteDirectory($tempDir);
        unlink($tempZipPath);

        return $zipPath;
    }

    private function addDirectoryToZip(ZipArchive $zip, string $dir, string $zipPath): void
    {
        $files = scandir($dir);
        foreach ($files as $file) {
            if ($file === '.' || $file === '..') {
                continue;
            }

            $filePath = $dir.'/'.$file;
            $zipFilePath = $zipPath ? $zipPath.'/'.$file : $file;

            if (is_dir($filePath)) {
                $zip->addEmptyDir($zipFilePath);
                $this->addDirectoryToZip($zip, $filePath, $zipFilePath);
            } else {
                $zip->addFile($filePath, $zipFilePath);
            }
        }
    }

    private function deleteDirectory(string $dir): void
    {
        if (! is_dir($dir)) {
            return;
        }

        $files = scandir($dir);
        foreach ($files as $file) {
            if ($file === '.' || $file === '..') {
                continue;
            }

            $path = $dir.'/'.$file;
            if (is_dir($path)) {
                $this->deleteDirectory($path);
            } else {
                unlink($path);
            }
        }
        rmdir($dir);
    }

    private function generateReadme(Project $project): string
    {
        $name = $project->name;
        $idea = $project->idea;
        $createdAt = $project->created_at->format('Y-m-d');

        return <<<MD
# {$name}

> Generated by PlanForge on {$createdAt}

## Project Idea

{$idea}

## Contents

- `docs/PRD.md` - Product Requirements Document
- `docs/TECH.md` - Technical Specification
- `kanban/tasks.json` - Tasks in JSON format (for re-import)
- `kanban/tasks.csv` - Tasks in CSV format (for PM tools)
- `meta.json` - Export metadata

## Getting Started

Review the PRD and Tech Spec to understand the project scope and implementation details.
Import `tasks.json` into your project management tool or use `tasks.csv` for manual tracking.
MD;
    }

    private function getPrdContent(Project $project): string
    {
        $doc = $project->documents->firstWhere('type', DocumentType::Prd);

        return $doc?->currentVersion?->content_md ?? '# PRD\n\nNo PRD generated yet.';
    }

    private function getTechContent(Project $project): string
    {
        $doc = $project->documents->firstWhere('type', DocumentType::Tech);

        return $doc?->currentVersion?->content_md ?? '# Technical Specification\n\nNo Tech Spec generated yet.';
    }

    private function generateTasksJson(Project $project): string
    {
        $tasks = $project->tasks->map(fn ($task) => [
            'id' => $task->id,
            'title' => $task->title,
            'description' => $task->description,
            'status' => $task->status->value,
            'position' => $task->position,
            'estimate' => $task->estimate,
            'labels' => $task->labels ?? [],
            'acceptance_criteria' => $task->acceptance_criteria ?? [],
            'depends_on' => $task->depends_on ?? [],
            'created_at' => $task->created_at->toIso8601String(),
            'updated_at' => $task->updated_at->toIso8601String(),
        ])->values();

        return json_encode([
            'project' => [
                'id' => $project->id,
                'name' => $project->name,
            ],
            'exported_at' => now()->toIso8601String(),
            'tasks' => $tasks,
        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    }

    private function generateTasksCsv(Project $project): string
    {
        $headers = ['id', 'title', 'description', 'status', 'position', 'estimate', 'labels', 'created_at', 'updated_at'];

        $output = fopen('php://temp', 'r+');
        fputcsv($output, $headers);

        foreach ($project->tasks as $task) {
            fputcsv($output, [
                $task->id,
                $task->title,
                $task->description,
                $task->status->value,
                $task->position,
                $task->estimate,
                implode(';', $task->labels ?? []),
                $task->created_at->toIso8601String(),
                $task->updated_at->toIso8601String(),
            ]);
        }

        rewind($output);
        $csv = stream_get_contents($output);
        fclose($output);

        return $csv;
    }

    private function generateMeta(Project $project): string
    {
        $prdDoc = $project->documents->firstWhere('type', DocumentType::Prd);
        $techDoc = $project->documents->firstWhere('type', DocumentType::Tech);
        $lastRun = $project->planRuns->first();

        return json_encode([
            'project_id' => $project->id,
            'project_name' => $project->name,
            'exported_at' => now()->toIso8601String(),
            'provider' => $lastRun?->provider ?? $project->preferred_provider,
            'model' => $lastRun?->model ?? $project->preferred_model,
            'versions' => [
                'prd' => $prdDoc?->current_version_id,
                'tech' => $techDoc?->current_version_id,
            ],
            'task_count' => $project->tasks->count(),
            'planforge_version' => '1.0.0',
        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    }

    private function generateFilename(Project $project): string
    {
        $slug = Str::slug($project->name);
        $date = now()->format('Y-m-d');

        return "{$slug}-project-kit-{$date}.zip";
    }
}
